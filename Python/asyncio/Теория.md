**asyncio** - это библиотека, реализующая выполнение нескольких задач в одном потоке.
Отличие синхронного, многопоточного и асихронного подходов:
![[Pasted image 20230328162202.png]]

**важно:** многопочность в python условная, так как GIL(глобальный ограничитель интерпретатора) позволяет использовать только один поток. Таким образом, реальная разница между threading и asycio состоит в том, что threading сам выбирает, какую корутину активировать и в какой момент, а asyncio требует явно задать точки входа в корутины и порядок исплонения.

asyncio используется когда нужно чего-то ждать, не останавливая работу остальной программы: веб/БД запросы, ввод пользователей итд.

**Пример.** Функции исполняются одна за другой, код исполняется 6 секунд:
```python
import time 

def fun1(x): 
	print(x**2) 
	time.sleep(3) 
	print('fun1 завершена') 
	
def fun2(x): print(x**0.5) 
	time.sleep(3) 
	print('fun2 завершена') 
	
def main(): 
	fun1(4) 
	fun2(4) 
	print(time.strftime('%X')) 
	
main() 
print(time.strftime('%X'))
```
Функции исполняются как только появляется возможность, код исполнятся 3 секунды:
```python
import asyncio 
import time 

async def fun1(x): 
	print(x**2) 
	await asyncio.sleep(3) 
	print('fun1 завершена') 

async def fun2(x):
	print(x**0.5)
	await asyncio.sleep(3) 
	print('fun2 завершена') 
	
async def main(): 
	task1 = asyncio.create_task(fun1(4)) 
	task2 = asyncio.create_task(fun2(4)) 
	await task1 
	await task2 

print(time.strftime('%X')) 
asyncio.run(main()) 
print(time.strftime('%X'))
```

Что изменилось:
1.  Перед определениями функций появился префикс `async`. Он говорит интерпретатору, что функция должна выполняться асинхронно.
2.  Вместо привычного `time.sleep` мы использовали `asyncio.sleep`. Это "неблокирующий sleep". В рамках функции ведет себя так же, как традиционный, но не останавливает интерпретатор в целом.
3.  Перед вызовом асинхронных функций появился префикс `await`. Он говорит интерпретатору примерно следующее: _"я тут возможно немного потуплю, но ты меня не жди — пусть выполняется другой код, а когда у меня будет настроение продолжиться, я тебе маякну"_.
4.  На базе функций мы при помощи `asyncio.create_task` создали задачи и запустили все это при помощи `asyncio.run`
5. Класс у функций в обоих примерах ```<class 'function'>```. Тип в первом примере ``<class 'NoneType'>`` , а во втором - ``<class 'coroutine'>``

**Корутина(coroutine)** - разновидность генератора(?), которая дает интерпретатору возможность возобновить базовую функцию, которая была приостановлена в месте размещения ключевого слова `await`.
**Корутина — это объект, который возвращает функция с `await`.**

**Футура** (future) — это оболочка для некой асинхронной сущности, позволяющая выполнять ее "как бы одновременно" с другими асинхронными сущностями, переключаясь от одной сущности к другой в точках, обозначенных ключевым словом `await`. Имеет внутреннюю переменную ``.result()``, которая устанавливается через ``.set_result(value)``
**Из докментации:** Футура это `awaitable`-объект. Корутины могут дождатиться объектов-футур, пока они не вернут результат, исключение, или пока футура не отменена. Футуру можно ожидать многократно, результат будет одним и тем же. 

**важно:** На базовом уровне приходистя иметь дело не с футурами, а с задачами

**Задача**(task) - **это частный случай футуры, предназначенный для оборачивания корутины.**

Таким образом, логика программы из примера выглядит так: 
-   корутину асинхронной функции `fun1` обернули задачей `task1`
-   корутину асинхронной функции `fun2` обернули задачей `task2`
-   в асинхронной функции main обозначили точку переключения к задаче `task1`
-   в асинхронной функции main обозначили точку переключения к задаче `task2`
-   корутину асинхронной функции `main` передали в функцию `asyncio.run`

**важно**: В `asyncio.run` нужно передавать асинхронную функцию с эвейтами на **задачи**, а не на корутины. Иначе оно будет работать, но сугубо последовательно, без конкурентности.

## Event loop

**eventloop(цикл событий)** - механизм, который выполняет корутины до тех пор, пока те не завершатся. Это можно представить как цикл `while True`, который отслеживает корутины, узнавая, когда те находятся в режиме ожидания, чтобы в этот момент выполнить что-нибудь другое.

Он может разбудить спящую корутину в тот момент, когда она ожидает своего времени, чтобы выполниться. В одно время может выполняться лишь один цикл событий в Python.
```python
import asyncio

async def async_func(task_no):
    print(f'{task_no}: Запуск ...')
    await asyncio.sleep(1)
    print(f'{task_no}: ... Готово!')

async def main():
    taskA = loop.create_task (async_func('taskA'))
    taskB = loop.create_task(async_func('taskB'))
    taskC = loop.create_task(async_func('taskC'))
    await asyncio.wait([taskA,taskB,taskC])

if __name__ == "__main__":
    try:
        loop = asyncio.new_event_loop()
        loop.run_until_complete(main())
    except :
        pass
```
Здесь был создан цикл событий `loop` и в него помещены 3 задачи. Далее цикл запускается методом `run_until_complete` - он останавливается если футура завершена.

**Ещё методы eventloop**
- `loop.run_forever()` - запустить цикл событий пока не вызван метод `stop()`
- `set_event_loop(loop)` - назначить `loop` текущим циклом событий для текущего потока 
- `loop.close()` - закрыть цикл событий, цикл не должен быть запущен, когда вызван этот метод. Он очищает все очереди и выключает исполнитель(?), но не дожидается пока  исполнитель завершится

