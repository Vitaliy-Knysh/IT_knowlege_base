
## Дорожная карта по теории
![[roadmap.png]]
### Массивы и связные списки(linked lists)

## Вне дорожной карты:

**итератор** - это объект, который возвращает свои элементы по одному за раз.
С точки зрения Python - это любой объект, у которого есть метод `__next__`. Этот метод возвращает следующий элемент, если он есть, или возвращает исключение StopIteration, когда элементы закончились.
Кроме того, итератор запоминает, на каком объекте он остановился в последнюю итерацию.
В Python у каждого итератора присутствует метод `__iter__` - то есть, любой итератор является итерируемым объектом. Этот метод просто возвращает сам итератор.

**генератор** - это итерируемые объекты, но прочитать их можно лишь один раз. Это связано с тем, что они не хранят значения в памяти, а генерируют их на лету.
Это список:
```python
>>> mylist = [x*x for x in range(3)] 
>>> for i in mylist : print(i) 
0 
1 
4
```
А это генератор:
```python
>>> mygenerator = (x*x for x in range(3))  
>>> for i in mygenerator : print(i) 
0 
1 
4
```

-   Объекты-генераторы не дают выигрыша по времени и памяти в том случае, если вам нужно хранить и работать сразу со всеми элементами коллекции, а не только с каким-то одним.
-   Объекты-генераторы не дают выигрыша по времени, если вы последовательно запрашиваете все элементы, которые могут быть получены.

## Ключевое слово yield

Оператор yield приостанавливает выполнение функции и возвращает указанное значение обратно вызывающей стороне, при этом происходит сохранение состояния, чтобы функция могла возобновить выполнение с того места, на котором она остановилась
```python
>>>def simple_generator():
>>>    yield 2
>>>    yield 4
>>>    yield 8

>>>for value in simple_generator(): 
>>>    print(value)
0 
1 
4
```
**важно**: когда вы вызываете функцию, код внутри тела функции не исполняется. Функция только возвращает объект-генератор. Код будет вызываться каждый раз, когда for обращается к генератору.

В первый запуск функции, она будет исполняться от начала до того момента, когда она наткнётся на yield — тогда она вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла, возвращаться будет следующее значение — и так пока значения не кончатся.  
  
Генератор считается пустым, как только при исполнении кода функции не встречается yield. Это может случиться из-за конца цикла, или же если не выполняется какое-то из условий «if/else».
