**ВАЖНО:**
- атрибутами класса являются и переменные внутри класса, и названия методов класса
- Экземпляр класса хранит не атрибуты родительского класса, а только указатель на пространство имён родительского класса

## Магические методы

**Методы `__new__()` и `__init()__`**
![[Pasted image 20230529173240.png]]

Для выполнения первого шага в классах Python есть специальный`__new__()`Использование метода `__new__()` в классах Python, который отвечает за создание и возврат нового пустого объекта. Затем другой метод `__init__()` принимает результирующий объект вместе с аргументами конструктора класса.
Пример: 
```python
class Point:
    def __new__(cls, *args, **kwargs):
        print("1. Создается новый экземпляр Point.")
        return super().__new__(cls)

    def __init__(self, x, y):
        print("2. Инициализируется новый экземпляр Point.")
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"{type(self).__name__}(x={self.x}, y={self.y})"
```

### Методы `__setattr__`, `__getattribute__`, `__getattr__` и `__delattr__`

Если есть необходимость изменить атрибут класса, обычный сеттер не сработает:
```python
(...)
def set_bound(self, left):
	self.MIN_COORD = left  
```
**Оператор присваивания создаёт атрибут с соответствующим именем в локальной области видимости**. В экземпляре класса атрибут отсутствует, поэтому он будет создан, а атрибут класса не изменится.
Правильное исполнение с таким подходом: 
```python
(...)
@classmethod
def set_bound(cls, left):
	cls.MIN_COORD = left  
```

![[Pasted image 20230531140436.png]]
`__getattribute__(self, item)`, где `item` - атрибут, к которому идёт обращение. Вызывается, например , когда происходит считывание атрибута через экземпляр класса.
`__getattribute__` можно использовать чтобы регулировать доступ к атрибутам класса:
```python

(...)
def __getattribute__(self, item):
	if item == 'x':
		raise ValueError("Параметр 'x' неизменямый")  
	return object.__getattribute__(self, item) 
```  
**класс object - родительcкий для всех объектов в Python 3**

метод `__setattr__(self, key, value)` автоматически вызывается каждый раз, когда присваивание атрибуту значения. `key` - название атрибута, `value` - значение.
Его можно использовать чтобы регулировать правила создания атрибутов:
```python
(...)
def __setattr__(self, key, value):
	if key == 'z':
		raise AttributeError('недопустимо имя атрибута')
	else: 
		object.__setattr__(self, key, value)
```  
Если внутри `__setattr__` напрямую присвоить значение атрибуту класса, метод уйдёт в рекурсию, так как при присвоении будет вызывать сам себя:
```python
(...)
def __setattr__(self, key, value):
	self.x = value  # приведет к рекурсии
	self.__dict__[key] = value # правильная реализация
```

метод `__getattr__(self, item)` вызывается каждый раз, когда идет обращение к несуществующему атрибуту класса.
Его можно использовать, чтобы при обращении к несуществующему атрибуту возвращать что-нибудь, а не генерировать исключение:
```python
(...)
def __getattr__(self, item):
	return False
```
метод `__delattr__(self, item)` вызывается каждый раз когда удаляется атрибут. Его можно использовать для контроля удаления атрибутов из экземпляров класса.

## Свойства (property), декоратор @property

Свойства - это более удобный способ работы с приватными атрибутами.
```python
class Person:
	def __init__(self, name, old)
		self.__name = name
		self.__old = old

	def get_old(self): 
		return self.__old
		
	def set_old(self, old): 
		self.__old = old
```
обычный метод работы с классом будет таким: 
```python
p = Person('Joe', 20)
p.set_old(35)
```
Этот метод неудобен тем, что к каждому атрибуту нужно обращаться через их собственные getter и setter. 
Как делать это через свойства:
```python
class Person:
(...)
	old = property(get_old, set_old)
```
Теперь из каждого экземпляра класса Person можно обращаться к атрибуту old.
![[Pasted image 20230531183435.png]]
При чтении данных автоматически вызывается getter, а при чтении - setter.

**ВАЖНО: при создании приватных атрибутов их название в `__dict__` меняется с `'<имя атрибута>'` на `'_<имя класса>__<имя атрибута>'`, например с `'old'` на `'_Person__old'`.**

У атрибутов-свойств приоритет выше, чем у обычных атрибутов. Так, если прописать `p.old = 35`, то вместо создания нового атрибута `old` в экземпляре `p`, будет изменён атрибут `__old` класса `Person`. Дело в приоритете: **если в классе задан атрибут-свойство, в первую очередь выбирается он.**

Чтобы избежать дублирования, используются декораторы:
```python
class Person:
(...)
	@property
	def old(self): 
		return self.__old

	@old.setter
	def old(self, old): 
		self.__old = old

	@old.deleter
	def old(self):
		del self.old
```



## Методы класса (classmethod) и статические методы (staticmethod)

**Декоратор @classmethod** создает метод, который может обращаться к атрибутам класса(тем, которые объявляются не в `__init__`), но не может обращаться к атрибутам экземпляра класса(тем, которые объявляются в `__init__`). На это дополнительно указывает то, что методы класса принимают как первый аргумент `cls`(указатель на класс) а не `self`(указатель на экземпляр класса). Поэтому метод класса можно вызывать и через название класса, и через название экземпляра. 
**по умолчанию метод класса нельзя использовать для изменения атрибутов экземпляра, т.к. у него нет указателя на экземпляр**

**Декоратор @staticmethod** создает метод, который не имеет доступа ни к атрибутам класса, ни к атрибутам объекта. Обычно это делают для удобства - для методов, функционально связанных с тематикой класса.
Пример:
```python
class Vector:
	MIN_COORD = 0
	MAX_COORD = 100

	@classmethod
	def validate(cls, arg):
		return MIN_COORD <= arg <= MAX_COORD

	def __init__(self, x, y):
		self.x = self.y = 0
		if self.validate(x) and self.validate(y):
			self.x = x
			self.y = y

	def get_coord(self):
		return self.x, self.y

	@staticmethod
	def norm2(x, y)
		return x*x + y*y

v = Vector(1, 5)
Vector.validate(3, 99)  # True
Vector.norm2(5, 6)  # 61
```

## Механизм инкапсуляции

- `attr` - __public__ атрибут
- `_attr` - __protected__ атрибут(служит для обращения внутри класса и во всех его дочерних классах). Подчеркивание не запрещает обращаться к атрибуту извне, а лишь указывает на то, что так делать не стоит
- `__attr` - __private__ атрибут(служит для обращения только внутри класса)
- то же самое справедливо для методов. объявлять их можно как с подчеркиваниями в названии, так и с декораторами `@private`, `@protected` из модуля **accessify**
Пример:
```python
class Point:

	def __init__(self, x1, x2, x3):
		self.x = 0
		self._x = 0
		self.__x = 0
		if self.__check_value(x3):
			self.x = x
			self._x = _x
			self.__x = __x

	@classmethod
	def __check_value(cls, x):
		return type(x) in (int, float)

	def set_coord(self, x, y): # типичный сеттер
		self.__x= 0
		if self.__check_value:
			self.__x = x
		else:
			raise ValueError('Координаты должны быть числами')

	def get_coord(self):  # типичный геттер
		return self.__x

pt = Point(1)
print(x) # сработает, т.к. атрибут публичный
print(_x) # тоже сработает, т.к _ это просто предостережение
print(__x) # не сработает
```
**Геттеры и сеттеры** нужны, потому что:
- они позволяют достичь инкапсуляции для скрытия состояния объекта и предотвращения прямого доступа к его полям  
- при реализации только геттера (без сеттера) можно достичь неизменяемости объекта  
- они могут предоставлять дополнительные функции: проверка корректности значения перед его присваиванием полю или обработка ошибок. Таким образом, мы можем добавить условную логику и обеспечить поведение в соответствии с потребностями (_если сеттер не имеет подобной логики, а лишь присваивает полю какое-то значение, то его наличие не обеспечивает инкапсуляцию. А его присутствие становится фиктивным_)
- можно предоставить полям разные уровни доступа: например, _get_ (доступ для чтения) может быть __public__, в то время как _set_ (доступ для записи) может быть __protected__

На самом деле обратиться к приватным атрибутам можно. Если прописать `print(dir(pt))`, то среди атрибутов будет `'_Point__x'`. Чтобы обратиться к private атрибуту, нужно прописать `pt._Point__x`. Аналогично с методами:  `pt._Point__check_value()`. Абсолютную защиту дает модуль **accessify**.

## Паттерны проектирования

### Паттерн singleton
Паттерн singleton описывает класс, который позволяет хранить в памяти только один объект.
Пример:
```python
class DataBase:
	__instance = None

	def __new__(cls, *args, **kwargs)
		if cls.__instance is None:
			cls.__instance = super().__new__(cls)
		return cls.__instance

	def __del__(self):
		DataBase.__instance = None

	def __init__(self, user, psw, port)
		self.user = user
		self.psw = psw
		self.port = port

	def connect(self):
		print(f'соединение с БД: {self.user}, {self.psw}, {self.port}')

	def close(self):
		print('соединение разорвано')

	def read(self):
		print 'данные из БД'

	def write(self):
		print(f'запись в БД')

db = DataBase('root', '1111', 80)
db2 = DataBase('user', '2222', 40)
print(id(db), id(db2))
```
Класс создает пользователя с именем, паролем и портом, и для вида имеет несколько методов. Атрибут `__instance = None` - это ссылка на экземпляр класса, по умолчанию равен `None`. Это даёт понять, существует ли объект класса. Переопределённый метод `__new__` проверяет, не существует ли объект класса `DataBase`. Если не существует, вызывается метод `__new__` родительского класса `Object`, создающий новый экземпляр. Если экземпляр уже существует, метод `__new__` возвращает его идентификатор. Метод `__del__` переопределяет идентификатор обратно в `None`. 
`print` выведет два одинаковых числа. Получается, что **указатели db и db2 ссылаются на один и тот же объект.**
**Недостаток этой реализации - обновление атрибутов экземпляра при попытке создания нового экземпляра**

### Паттерн "Моносостояние"

Идея паттерна - чтобы все экземпляры класса имели одинаковые атрибуты. Например, в двух потоках находятся два экземпляра одного класса, имеющие одни и те же локальные свойства:
![[Pasted image 20230531173255.png]]

```python
class ThreadData:
	__shared_attrs = {
		'name': 1, 
		'data': 2, 
		'id': 3
	}

	def __init__(self):
		self.__dict__ = self.__shared_attrs
```
Таким образом, при создании нового экземпляра, указатель на словарь, описывающий его структуру, будет ссылаться на `__shared_attrs`.
Если создать два экземпляра класса `ThreadData` и поменять в одном экземпляре, например, `id`, то в другом `id` тоже изменится. То же самое справедливо для создания/удаления атрибутов, т.к. изменения происходят в пространстве имён родительского класса.